#! /bin/bash
#
# Run script for flywheel/hcp-struct Gear.
#
# Authorship: Keith Jamison
#

##############################################################################
# Define directory names and containers

FLYWHEEL_BASE=/flywheel/v0
INPUT_DIR=$FLYWHEEL_BASE/input
OUTPUT_DIR=$FLYWHEEL_BASE/output
SCRIPT_DIR=${FLYWHEEL_BASE}/scripts
SCENE_DIR=${FLYWHEEL_BASE}/scenes
CONFIG_FILE=$FLYWHEEL_BASE/config.json
CONTAINER='[flywheel/hcp-struct]'

source ${FLYWHEEL_BASE}/docker-env.sh

source ${SCRIPT_DIR}/bash_functions.sh # some useful tools


##############################################################################
# Parse configuration

# If the config file does not exist (i.e., local run) then parse the config
# options and values from the manifest. Those variables can be found in the
# manifest.json file within the `config` map.

if [[ -f $CONFIG_FILE ]]; then
  eval $(jq -r '.inputs | to_entries[] | "FW_INPUT_\(.key)=\(.value.location.path)"' $CONFIG_FILE)
  echo "$(env | grep INPUT)"
fi


function parse_config {
  CONFIG_FILE=$FLYWHEEL_BASE/config.json
  MANIFEST_FILE=$FLYWHEEL_BASE/manifest.json

  if [[ -f $CONFIG_FILE ]]; then
    echo -e "$(cat $CONFIG_FILE | jq -r '.config.'$1)"
  else
    CONFIG_FILE=$MANIFEST_FILE
    echo -e "$(cat $MANIFEST_FILE | jq -r '.config.'$1'.default')"
  fi
}

FW_CONFIG_Subject="$(parse_config 'Subject')"
FW_CONFIG_RegName="$(parse_config 'RegName')"
FW_CONFIG_BrainSize="$(parse_config 'BrainSize')"
FW_CONFIG_TemplateSize="$(parse_config 'TemplateSize')"
FW_CONFIG_StructuralUnwarpDirection="$(parse_config 'StructuralUnwarpDirection')"


##############################################################################
# use "echo" for testing arguments without running scripts

RUN_PRE=""
RUN_FS=""
RUN_POST=""
RUN_QC=""

##############################################################################
# Set some pipeline defaults

source ${SCRIPT_DIR}/SetUpHCPPipeline.sh

StudyFolder=${OUTPUT_DIR}

PRINTCOM=""
QUEUE=""

LogFileDir=logs
LogFileDirFull=${OUTPUT_DIR}/${LogFileDir}
mkdir -p ${LogFileDirFull}
FSLSUBOPTIONS="-l ${LogFileDirFull}"

#Default Config Settings
RegName="FS"
StructuralUnwarpDir="z" #z appears to be best or "NONE" if not used
StructuralDeltaTE="NONE" #DeltaTE for GRE fieldmap used to correct STRUCTURAL
StructuralDwellTime="NONE" # DwellTime for SpinEchoFieldMap when TOPUP is used for STRUCTURAL (ie: not T1wSampleSpacing)

AvgrdcSTRING="NONE" # = Distortion correction for Structural pipeline (NONE, FIELDMAP==SiemensFieldMap, GeneralElectricFieldMap, TOPUP)
# --> TOPUP requires SpinEchoPhaseEncodeNegative, SpinEchoPhaseEncodePositive
# --> SiemensFieldMap requires MagnitudeInputName, PhaseInputName
# --> GeneralElectricFieldMap requires GEB0InputName

GEB0InputName="NONE"
SpinEchoPhaseEncodeNegative="NONE"
SpinEchoPhaseEncodePositive="NONE"
MagnitudeInputName="NONE"
PhaseInputName="NONE"
UnwarpDir="NONE"
SEUnwarpDir="NONE"

GradientDistortionCoeffs="NONE" #no gradient correction unless we are provided with a .grad file

#######################################
# Process inputs and config options from app


if [[ -z "${FW_INPUT_T1}" ]]; then
  echo -e "$CONTAINER [$(timestamp)] INPUT_DIR has no valid T1w files!"
  exit 1
else
  T1wInputImages="${FW_INPUT_T1}"
fi

if [[ -z "${FW_INPUT_T2}" ]]; then
  echo -e "$CONTAINER [$(timestamp)] INPUT_DIR has no valid T2w files!"
  exit 1
else
  T2wInputImages="${FW_INPUT_T2}"
fi

# Read necessary acquisition params from T1w and T2w
#TODO: Derive UnwarpDir from json header (not currently available)
T1wSampleSpacing=$(print_decimal_number $(jq -r '.inputs["T1"].object.info.DwellTime // empty' ${CONFIG_FILE}))
T2wSampleSpacing=$(print_decimal_number $(jq -r '.inputs["T2"].object.info.DwellTime // empty' ${CONFIG_FILE}))

if [[ -e "${FW_INPUT_GradientCoeff}" ]]; then
  GradientDistortionCoeffs="${FW_INPUT_GradientCoeff}"
  #TODO: add "siemens" vs "GE" to pipeline for gradient unwarping
  #GradientDistortionCoeffs_vendor="siemens"
fi

# For Siemens FieldMap, must include Magnitude and Phase inputs.  Extract deltaTE automatically
if [[ -e "${FW_INPUT_SiemensGREPhase}" ]] && [[ -e "${FW_INPUT_SiemensGREMagnitude}" ]]; then
  MagnitudeInputName="${FW_INPUT_SiemensGREMagnitude}"
  PhaseInputName="${FW_INPUT_SiemensGREPhase}"
  AvgrdcSTRING="SiemensFieldMap"

  #Ideally, FieldMap_Phase .json would contain EchoTime1 and EchoTime2
  #echotime1=$(jq -r '.inputs["SiemensGREPhase"].object.info.EchoTime1 // empty' ${CONFIG_FILE})
  #echotime2=$(jq -r '.inputs["SiemensGREPhase"].object.info.EchoTime2 // empty' ${CONFIG_FILE})

  echotime1=$(jq -r '.inputs["SiemensGREMagnitude"].object.info.EchoTime // empty' ${CONFIG_FILE})
  echotime2=$(jq -r '.inputs["SiemensGREPhase"].object.info.EchoTime // empty' ${CONFIG_FILE})

  if [[ -z "$echotime1" ]] || [[ -z "$echotime2" ]]; then
    echo -e "${CONTAINER} [$(timestamp)] No EchoTime metadata found in FieldMap input file!  Exiting."
    exit 1
  elif [[ "$echotime1" == "$echotime2" ]]; then
    echo -e "${CONTAINER} [$(timestamp)] EchoTime1 and EchoTime2 are the same (Please ensure Magnitude input is TE1)! Exiting."
    exit 1
  fi

  echotime1=$(print_decimal_number $echotime1)
  echotime2=$(print_decimal_number $echotime2)
  StructuralDeltaTE=$(echo "($echotime2 - $echotime1)*1000.0" | bc -l)

# For SpinEcho "TOPUP" FieldMap, must include both Pos and Neg phase encode
elif [[ -e "${FW_INPUT_SpinEchoNegative}" ]] && [[ -e "${FW_INPUT_SpinEchoPositive}" ]]; then
  SpinEchoPhase1="${FW_INPUT_SpinEchoPositive}"
  SpinEchoPhase2="${FW_INPUT_SpinEchoNegative}"

  pedirSE1=$(jq -r '.inputs["SpinEchoPositive"].object.info.PhaseEncodingDirection // empty' ${CONFIG_FILE})
  pedirSE2=$(jq -r '.inputs["SpinEchoNegative"].object.info.PhaseEncodingDirection // empty' ${CONFIG_FILE})
  pedirSE1=$( echo "$pedirSE1" | tr "[ijk]" "[xyz]" )
  pedirSE2=$( echo "$pedirSE2" | tr "[ijk]" "[xyz]" )

  if [[ -z "${pedirSE1}" ]]; then
    echo -e "${CONTAINER} [$(timestamp)] SpinEchoPositive input is missing PhaseEncodingDirection metadata!"
    exit 1
  elif [[ -z "${pedirSE2}" ]]; then
    echo -e "${CONTAINER} [$(timestamp)] SpinEchoNegative input data is missing PhaseEncodingDirection metadata!"
    exit 1
  elif [[ "${pedirSE1}" == "${pedirSE2}" ]]; then
    echo -e "${CONTAINER} [$(timestamp)] SpinEchoPositive and SpinEchoNegative have the same PhaseEncodingDirection (${pedirSE1})!"
    exit 1
  fi

  if [[ "${pedirSE1},${pedirSE2}" == "x,x-" ]] || [[ "${pedirSE1},${pedirSE2}" == "y,y-" ]]; then
    SpinEchoPhaseEncodePositive="${SpinEchoPhase1}"
    SpinEchoPhaseEncodeNegative="${SpinEchoPhase2}"
  elif [[ "${pedirSE1},${pedirSE2}" == "x-,x" ]] || [[ "${pedirSE1},${pedirSE2}" == "y-,y" ]]; then
    SpinEchoPhaseEncodePositive="${SpinEchoPhase2}"
    SpinEchoPhaseEncodeNegative="${SpinEchoPhase1}"
    echo -e "${CONTAINER} [$(timestamp)] SpinEcho phase-encoding directions were swapped. Continuing!"
  else
    echo -e "${CONTAINER} [$(timestamp)] Unrecognized SpinEcho phase-encoding directions (${pedirSE1},${pedirSE2})!"
    exit 1
  fi

  StructuralDwellTime=$(print_decimal_number $(jq -r '.inputs["SpinEchoPositive"].object.info.EffectiveEchoSpacing // empty' ${CONFIG_FILE}))
  TopupDwellTime=$(print_decimal_number $(jq -r '.inputs["SpinEchoPositive"].object.info.EffectiveEchoSpacing // empty' ${CONFIG_FILE}))
  pedirSE_plane=$( echo "${pedirSE1}" | sed -E 's/[-+]//g' )
  SEUnwarpDir=${pedirSE_plane}
  AvgrdcSTRING="TOPUP"

elif [[ -e "${FW_INPUT_GeneralElectricFieldMap}" ]]; then
  #TODO: how do we handle GE fieldmap? where do we get deltaTE?
  echo -e "${CONTAINER} [$(timestamp)] Cannot currently handle GeneralElectricFieldmap!"
  exit 1

  #GEB0InputName="${FW_INPUT_GeneralElectricFieldMap}"
  #AvgrdcSTRING="GeneralElectricFieldMap"
fi

# Install FreeSurfer license
if [[ -e "${FW_INPUT_FreeSurferLicense}" ]]; then
  echo -e "$CONTAINER [$(timestamp)] Copying user-supplied FreeSurfer license file to ${FREESURFER_HOME}/license.txt"
  cp -f "${FW_INPUT_FreeSurferLicense}" ${FREESURFER_HOME}/license.txt
fi

# Check RegName config
case $(toupper "${FW_CONFIG_RegName}") in
  FS|MSMSULC)
    RegName="${FW_CONFIG_RegName}"
    ;;
  *)
    echo -e "$CONTAINER [$(timestamp)] RegName must be FS or MSMSulc!"
    exit 1
    ;;
esac

Subject=${FW_CONFIG_Subject}
BrainSize=${FW_CONFIG_BrainSize}
TemplateSize=${FW_CONFIG_TemplateSize}
UnwarpDir=${FW_CONFIG_StructuralUnwarpDirection}

DeltaTE=$StructuralDeltaTE                        # GRE B0 FieldMap DeltaTE (if used)
DwellTime=$StructuralDwellTime                    # SpinEcho FieldMap DwellTime (if used)

# Some options that may become user-specified in the future, but use standard HCP values for now
GrayordinatesResolution="2"                       # Usually 2mm ("1.6" also available)
LowResMesh="32"                                   # Usually 32k vertices ("59" = 1.6mm)
GrayordinatesTemplate="91282_Greyordinates"       # (or 170494_Greyordinates = 1.6mm)

HighResMesh="164"                                 # Basically always 164k vertices

#######################################
# Additional pipeline inputs
FNIRTConfig="${HCPPIPEDIR_Config}/T1_2_MNI152_2mm.cnf" #FNIRT 2mm T1w Config
TopupConfig="${HCPPIPEDIR_Config}/b02b0.cnf" #Topup config if using TOPUP, set to NONE if using regular FIELDMAP

SurfaceAtlasDIR="${HCPPIPEDIR_Templates}/standard_mesh_atlases" #(Need to rename make surf.gii and add 32k)
GrayordinatesSpaceDIR="${HCPPIPEDIR_Templates}/${GrayordinatesTemplate}" #(Need to copy these in)
SubcorticalGrayLabels="${HCPPIPEDIR_Config}/FreeSurferSubcorticalLabelTableLut.txt"
FreeSurferLabels="${HCPPIPEDIR_Config}/FreeSurferAllLut.txt"
ReferenceMyelinMaps="${HCPPIPEDIR_Templates}/standard_mesh_atlases/Conte69.MyelinMap_BC.164k_fs_LR.dscalar.nii"

# MNI Atlas NIFTI files
T1wTemplate="${HCPPIPEDIR_Templates}/MNI152_T1_${TemplateSize}.nii.gz" #MNI0.7mm template
T1wTemplateBrain="${HCPPIPEDIR_Templates}/MNI152_T1_${TemplateSize}_brain.nii.gz" #Brain extracted MNI0.7mm template
T1wTemplate2mm="${HCPPIPEDIR_Templates}/MNI152_T1_2mm.nii.gz" #MNI2mm template
T2wTemplate="${HCPPIPEDIR_Templates}/MNI152_T2_${TemplateSize}.nii.gz" #MNI0.7mm T2wTemplate
T2wTemplateBrain="${HCPPIPEDIR_Templates}/MNI152_T2_${TemplateSize}_brain.nii.gz" #Brain extracted MNI0.7mm T2wTemplate
T2wTemplate2mm="${HCPPIPEDIR_Templates}/MNI152_T2_2mm.nii.gz" #MNI2mm T2wTemplate
TemplateMask="${HCPPIPEDIR_Templates}/MNI152_T1_${TemplateSize}_brain_mask.nii.gz" #Brain mask MNI0.7mm template
Template2mmMask="${HCPPIPEDIR_Templates}/MNI152_T1_2mm_brain_mask_dil.nii.gz" #MNI2mm template

# Check templates selected via user inputs exist
if [[ ! -e "${T1wTemplate}" ]]; then
  echo -e "${CONTAINER} [$(timestamp)] Template image not found: ${T1wTemplate}! Invalid Template Size parameter specified: ${TemplateSize}"
  exit 1
fi

if [[ ! -e "${GrayordinatesSpaceDIR}" ]]; then
  echo -e "${CONTAINER} [$(timestamp)] Grayordinates directory not found: ${GrayordinatesSpaceDIR}!"
  exit 1
fi
################################################################################
# Run PreFreeSurferPipeline.sh

echo -e "${CONTAINER} [$(timestamp)] Starting: PreFreeSurfer Pipeline"

mkdir -p ${StudyFolder}/${Subject}

pipeline_status_code=0

set -x
${RUN_PRE} ${FSLDIR}/bin/fsl_sub ${QUEUE} ${FSLSUBOPTIONS} \
   ${HCPPIPEDIR}/PreFreeSurfer/PreFreeSurferPipeline.sh \
    --path="$StudyFolder" \
    --subject="$Subject" \
    --t1="$T1wInputImages" \
    --t2="$T2wInputImages" \
    --t1template="$T1wTemplate" \
    --t1templatebrain="$T1wTemplateBrain" \
    --t1template2mm="$T1wTemplate2mm" \
    --t2template="$T2wTemplate" \
    --t2templatebrain="$T2wTemplateBrain" \
    --t2template2mm="$T2wTemplate2mm" \
    --templatemask="$TemplateMask" \
    --template2mmmask="$Template2mmMask" \
    --brainsize="$BrainSize" \
    --fnirtconfig="$FNIRTConfig" \
    --fmapmag="$MagnitudeInputName" \
    --fmapphase="$PhaseInputName" \
    --fmapgeneralelectric="$GEB0InputName" \
    --echodiff="$DeltaTE" \
    --SEPhaseNeg="$SpinEchoPhaseEncodeNegative" \
    --SEPhasePos="$SpinEchoPhaseEncodePositive" \
    --echospacing="$DwellTime" \
    --seunwarpdir="$SEUnwarpDir" \
    --t1samplespacing="$T1wSampleSpacing" \
    --t2samplespacing="$T2wSampleSpacing" \
    --unwarpdir="$UnwarpDir" \
    --gdcoeffs="$GradientDistortionCoeffs" \
    --avgrdcmethod="$AvgrdcSTRING" \
    --topupconfig="$TopupConfig" \
    --printcom=$PRINTCOM
set +x

pipeline_status_code=$?

if [[ $pipeline_status_code == 0 ]]; then
  echo -e "${CONTAINER} [$(timestamp)] PreFreeSurfer Pipeline Success!"
else
  echo -e "${CONTAINER} [$(timestamp)] PreFreeSurfer Pipeline Failure!"
  exit 1
fi

################################################################################
# Run FreeSurferPipeline.sh

echo -e "${CONTAINER} [$(timestamp)] Starting: FreeSurfer Pipeline"

SubjectDIR="${StudyFolder}/${Subject}/T1w" #Location to Put FreeSurfer Subject's Folder
T1wImage="${StudyFolder}/${Subject}/T1w/T1w_acpc_dc_restore.nii.gz" #T1w FreeSurfer Input (Full Resolution)
T1wImageBrain="${StudyFolder}/${Subject}/T1w/T1w_acpc_dc_restore_brain.nii.gz" #T1w FreeSurfer Input (Full Resolution)
T2wImage="${StudyFolder}/${Subject}/T1w/T2w_acpc_dc_restore.nii.gz" #T2w FreeSurfer Input (Full Resolution)

set -x
${RUN_FS} ${FSLDIR}/bin/fsl_sub ${QUEUE} ${FSLSUBOPTIONS} \
   ${HCPPIPEDIR}/FreeSurfer/FreeSurferPipeline.sh \
    --subject="$Subject" \
    --subjectDIR="$SubjectDIR" \
    --t1="$T1wImage" \
    --t1brain="$T1wImageBrain" \
    --t2="$T2wImage" \
    --printcom=$PRINTCOM
set +x

pipeline_status_code=$?

if [[ $pipeline_status_code == 0 ]]; then
  echo -e "${CONTAINER} [$(timestamp)] FreeSurfer Pipeline Success!"
else
  echo -e "${CONTAINER} [$(timestamp)] FreeSurfer Pipeline Failure!"
  exit 1
fi

################################################################################
# Run PostFreeSurferPipeline.sh

echo -e "${CONTAINER} [$(timestamp)] Starting: PostPreFreeSurfer Pipeline"

set -x
${RUN_POST} ${FSLDIR}/bin/fsl_sub ${QUEUE} ${FSLSUBOPTIONS} \
   ${HCPPIPEDIR}/PostFreeSurfer/PostFreeSurferPipeline.sh \
    --path="$StudyFolder" \
    --subject="$Subject" \
    --surfatlasdir="$SurfaceAtlasDIR" \
    --grayordinatesdir="$GrayordinatesSpaceDIR" \
    --grayordinatesres="$GrayordinatesResolution" \
    --hiresmesh="$HighResMesh" \
    --lowresmesh="$LowResMesh" \
    --subcortgraylabels="$SubcorticalGrayLabels" \
    --freesurferlabels="$FreeSurferLabels" \
    --refmyelinmaps="$ReferenceMyelinMaps" \
    --regname="$RegName" \
    --printcom=$PRINTCOM
set +x

pipeline_status_code=$?

if [[ $pipeline_status_code == 0 ]]; then
  echo -e "${CONTAINER} [$(timestamp)] PostFreeSurfer Pipeline Success!"
else
  echo -e "${CONTAINER} [$(timestamp)] PostFreeSurfer Pipeline Failure!"
  exit 1
fi

################################################################################
# Generate HCPStructural QC Images

echo -e "${CONTAINER} [$(timestamp)] Starting: Structural QC Image Generation"

qc_scene_template="${SCENE_DIR}/TEMPLATE.hcpstruct_QC.very_inflated.164k_fs_LR.scene"
qc_scene_file="${StudyFolder}/${Subject}/MNINonLinear/${Subject}.hcpstruct_QC.164k_fs_LR.scene"
qc_scene_root="${StudyFolder}/${Subject}/"

qc_outputdir="${StudyFolder}"
mkdir -p ${qc_outputdir}

qc_image_root="${qc_outputdir}/${Subject}.hcpstruct_QC."
qc_image_params="1440 900" #qc image size

set -x
${RUN_QC} ${SCRIPT_DIR}/hcpstruct_qc_scenes.sh \
  ${qc_scene_template} \
  ${qc_scene_file} \
  ${Subject} \
  ${qc_scene_root} \
  ${qc_image_root}inflated_ \
  ${qc_image_params} > ${LogFileDirFull}/structuralqc.log

${RUN_QC} ${SCRIPT_DIR}/hcpstruct_qc_mosaic.sh \
  ${qc_scene_root} \
  ${T1wTemplateBrain} \
  ${qc_image_root} >> ${LogFileDirFull}/structuralqc.log

set +x

pipeline_status_code=$?

if [[ $pipeline_status_code == 0 ]]; then
  echo -e "${CONTAINER} [$(timestamp)] Structural QC Image Generation Success!"
  echo -e "${CONTAINER} [$(timestamp)] Structural Pipeline Complete!"
else
  echo -e "${CONTAINER} [$(timestamp)] Structural QC Image Generation Failure!"
  exit 1
fi

################################################################################
# Clean-up and output prep

# Add current gear config.json to output for reference in subsequent gears
# - For now, don't copy full input json since it might contain identifiers from DICOM etc
# - add/update .config.RegName since it might not have been included in config (pre-MSM availability)
# - add/update .config.Subject since it might later be pulled from other session metadata
# - This jq call does the value replacement, then selects just .config but stores it back into a
#    new element called ".config" so the new file can be read as though it was flywheel config.json
OUTPUT_CONFIG_FILE=${StudyFolder}/${Subject}/${Subject}_hcpstruct_config.json
jq -r '.config.RegName = "'"${RegName}"'" | .config.Subject = "'"${Subject}"'" | .config | {config: .}' $CONFIG_FILE \
  | jq -r '.config.GrayordinatesResolution = "'"${GrayordinatesResolution}"'"' \
  | jq -r '.config.GrayordinatesTemplate = "'"${GrayordinatesTemplate}"'"' \
  | jq -r '.config.HighResMesh = "'"${HighResMesh}"'"' \
  | jq -r '.config.LowResMesh = "'"${LowResMesh}"'"' > ${OUTPUT_CONFIG_FILE}

# If pipeline successful, zip outputs and clean up
outputzipname=${Subject}_hcpstruct.zip
echo -e "${CONTAINER} [$(timestamp)] Zipping output file ${outputzipname}"
cd ${StudyFolder}
rm -f ${OUTPUT_DIR}/${outputzipname}
zip -r ${OUTPUT_DIR}/${outputzipname} ${Subject}/ > ${OUTPUT_DIR}/${outputzipname}.log

# zip pipeline logs
logzipname=pipeline_logs.zip
echo -e "${CONTAINER} [$(timestamp)] Zipping pipeline logs to ${logzipname}"
cd ${OUTPUT_DIR}
rm -f ${OUTPUT_DIR}/${logzipname}
zip -r ${OUTPUT_DIR}/${logzipname} ${LogFileDir}/ > ${OUTPUT_DIR}/${logzipname}.log

echo -e "${CONTAINER} [$(timestamp)] Cleaning output directory"
rm -rf ${StudyFolder}/${Subject}/
rm -rf ${LogFileDirFull}/

echo -e "${CONTAINER} [$(timestamp)] Final output directory listing:"
cd ${OUTPUT_DIR}
du -hs *

exit $pipeline_status_code
